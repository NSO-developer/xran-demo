# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_user_xran_usermgmt__xran_users_user(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module xran-usermgmt - based on the path /xran-users/user. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of local users configured on this device.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__password','__enabled',)

  _yang_name = 'user'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__password = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[a-zA-Z0-9!$%\\^()\\[\\]_\\-~{}.+]*', u'length': [u'8..128']}), is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='password-type', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[a-z][a-z0-9]{2,31}', u'length': [u'3..32']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='username-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'xran-users', u'user']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /xran_users/user/name (username-type)

    YANG Description: The user name string identifying this entry.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /xran_users/user/name (username-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The user name string identifying this entry.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[a-z][a-z0-9]{2,31}', u'length': [u'3..32']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='username-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with username-type""",
          'defined-type': "xran-usermgmt:username-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[a-z][a-z0-9]{2,31}', u'length': [u'3..32']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='username-type', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[a-z][a-z0-9]{2,31}', u'length': [u'3..32']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='username-type', is_config=True)


  def _get_password(self):
    """
    Getter method for password, mapped from YANG variable /xran_users/user/password (password-type)

    YANG Description: The password for this entry.
    """
    return self.__password
      
  def _set_password(self, v, load=False):
    """
    Setter method for password, mapped from YANG variable /xran_users/user/password (password-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password() directly.

    YANG Description: The password for this entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[a-zA-Z0-9!$%\\^()\\[\\]_\\-~{}.+]*', u'length': [u'8..128']}), is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='password-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password must be of a type compatible with password-type""",
          'defined-type': "xran-usermgmt:password-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[a-zA-Z0-9!$%\\^()\\[\\]_\\-~{}.+]*', u'length': [u'8..128']}), is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='password-type', is_config=True)""",
        })

    self.__password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password(self):
    self.__password = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[a-zA-Z0-9!$%\\^()\\[\\]_\\-~{}.+]*', u'length': [u'8..128']}), is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='password-type', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /xran_users/user/enabled (boolean)

    YANG Description: Indicates whether an account is enabled or disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /xran_users/user/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates whether an account is enabled or disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  password = __builtin__.property(_get_password, _set_password)
  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('name', name), ('password', password), ('enabled', enabled), ])


class yc_xran_users_xran_usermgmt__xran_users(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module xran-usermgmt - based on the path /xran-users. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: list of user accounts
  """
  __slots__ = ('_path_helper', '_extmethods', '__user',)

  _yang_name = 'xran-users'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user = YANGDynClass(base=YANGListType("name",yc_user_xran_usermgmt__xran_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'xran-users']

  def _get_user(self):
    """
    Getter method for user, mapped from YANG variable /xran_users/user (list)

    YANG Description: The list of local users configured on this device.
    """
    return self.__user
      
  def _set_user(self, v, load=False):
    """
    Setter method for user, mapped from YANG variable /xran_users/user (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.

    YANG Description: The list of local users configured on this device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_user_xran_usermgmt__xran_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_user_xran_usermgmt__xran_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='list', is_config=True)""",
        })

    self.__user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user(self):
    self.__user = YANGDynClass(base=YANGListType("name",yc_user_xran_usermgmt__xran_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='list', is_config=True)

  user = __builtin__.property(_get_user, _set_user)


  _pyangbind_elements = OrderedDict([('user', user), ])


class xran_usermgmt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module xran-usermgmt - based on the path /xran-usermgmt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the user management model for the xRAN Radio Unit.
The model is an augmentation of the user management model defined by
the openroadm MSA.

Copyright 2018 the xRAN Forum.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
this list of conditions and the above disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the above disclaimer in the documentation
and/or other materials provided with the distribution.
* Neither the Members of the xRAN Forum nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.
  """
  __slots__ = ('_path_helper', '_extmethods', '__xran_users',)

  _yang_name = 'xran-usermgmt'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__xran_users = YANGDynClass(base=yc_xran_users_xran_usermgmt__xran_users, is_container='container', yang_name="xran-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_xran_users(self):
    """
    Getter method for xran_users, mapped from YANG variable /xran_users (container)

    YANG Description: list of user accounts
    """
    return self.__xran_users
      
  def _set_xran_users(self, v, load=False):
    """
    Setter method for xran_users, mapped from YANG variable /xran_users (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_xran_users is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_xran_users() directly.

    YANG Description: list of user accounts
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_xran_users_xran_usermgmt__xran_users, is_container='container', yang_name="xran-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """xran_users must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_xran_users_xran_usermgmt__xran_users, is_container='container', yang_name="xran-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='container', is_config=True)""",
        })

    self.__xran_users = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_xran_users(self):
    self.__xran_users = YANGDynClass(base=yc_xran_users_xran_usermgmt__xran_users, is_container='container', yang_name="xran-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:xran:user-mgmt:2.0', defining_module='xran-usermgmt', yang_type='container', is_config=True)

  xran_users = __builtin__.property(_get_xran_users, _set_xran_users)


  _pyangbind_elements = OrderedDict([('xran_users', xran_users), ])


